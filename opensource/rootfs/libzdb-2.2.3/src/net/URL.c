/* Generated by re2c 0.13.5 on Thu Jul 10 20:24:43 2008 */
#line 1 "src/net/URL.re"
/*
 * Copyright (C) 2008 Tildeslash Ltd. All rights reserved.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */


#include "Config.h"

#include <stdio.h>
#include <stdarg.h>
#include <string.h>
#include <stdlib.h>
#include <limits.h>

#include "URL.h"


/**
 * Implementation of the URL interface. URL_create() does not 
 * handle wide character code but URL_new() does. The scanner 
 * handle ISO Latin 1 or UTF-8 encoded url's transparently.
 *
 * @version \$Id: URL.c,v 1.1 2008/11/12 13:25:56 wiley Exp $
 * @file
 */


/* ----------------------------------------------------------- Definitions */

typedef struct param_t {
        char *name;
        char *value;
        struct param_t *next;
} *param_t;

#define T URL_T
struct T {
	int port;
       	char *ref;
	char *path;
	char *host;
	char *user;
        char *qptr;
	char *query;
	char *portStr;
	char *protocol;
	char *password;
	char *toString;
        param_t params;
        char **paramNames;
	uchar_t *data;
	uchar_t *buffer;
	uchar_t *marker, *ctx, *limit, *token;
        /* Keep the above align with zild URL_T */
};

/* Unsafe URL characters: [00-1F, 7F-FF] <>\"#%{}|\\^[] ` */
static const uchar_t urlunsafe[256] = {
	1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 
	1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 
	1, 0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 
	1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 1, 
	1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 
	1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 
	1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 
	1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 
	1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 
	1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 
	1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 
	1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1
};

static const uchar_t b2x[][256] = {
        "00", "01", "02", "03", "04", "05", "06", "07", 
        "08", "09", "0A", "0B", "0C", "0D", "0E", "0F", 
        "10", "11", "12", "13", "14", "15", "16", "17", 
        "18", "19", "1A", "1B", "1C", "1D", "1E", "1F", 
        "20", "21", "22", "23", "24", "25", "26", "27", 
        "28", "29", "2A", "2B", "2C", "2D", "2E", "2F", 
        "30", "31", "32", "33", "34", "35", "36", "37", 
        "38", "39", "3A", "3B", "3C", "3D", "3E", "3F", 
        "40", "41", "42", "43", "44", "45", "46", "47", 
        "48", "49", "4A", "4B", "4C", "4D", "4E", "4F", 
        "50", "51", "52", "53", "54", "55", "56", "57", 
        "58", "59", "5A", "5B", "5C", "5D", "5E", "5F", 
        "60", "61", "62", "63", "64", "65", "66", "67", 
        "68", "69", "6A", "6B", "6C", "6D", "6E", "6F", 
        "70", "71", "72", "73", "74", "75", "76", "77", 
        "78", "79", "7A", "7B", "7C", "7D", "7E", "7F",
        "80", "81", "82", "83", "84", "85", "86", "87", 
        "88", "89", "8A", "8B", "8C", "8D", "8E", "8F",
        "90", "91", "92", "93", "94", "95", "96", "97", 
        "98", "99", "9A", "9B", "9C", "9D", "9E", "9F", 
        "A0", "A1", "A2", "A3", "A4", "A5", "A6", "A7", 
        "A8", "A9", "AA", "AB", "AC", "AD", "AE", "AF", 
        "B0", "B1", "B2", "B3", "B4", "B5", "B6", "B7", 
        "B8", "B9", "BA", "BB", "BC", "BD", "BE", "BF", 
        "C0", "C1", "C2", "C3", "C4", "C5", "C6", "C7", 
        "C8", "C9", "CA", "CB", "CC", "CD", "CE", "CF",
        "D0", "D1", "D2", "D3", "D4", "D5", "D6", "D7", 
        "D8", "D9", "DA", "DB", "DC", "DD", "DE", "DF", 
        "E0", "E1", "E2", "E3", "E4", "E5", "E6", "E7", 
        "E8", "E9", "EA", "EB", "EC", "ED", "EE", "EF", 
        "F0", "F1", "F2", "F3", "F4", "F5", "F6", "F7", 
        "F8", "F9", "FA", "FB", "FC", "FD", "FE", "FF"
};


#define BUFFER_SIZE 8192
#define UNKNOWN_PORT -1
#define YYCTYPE       uchar_t
#define YYCURSOR      U->buffer  
#define YYLIMIT       U->limit  
#define YYMARKER      U->marker
#define YYMARKER      U->marker
#define YYCTXMARKER   U->ctx
#define YYFILL(n)     ((void)0)
#define YYTOKEN       U->token
#define SET_PROTOCOL(PORT) *(YYCURSOR-3)=0; \
	U->protocol=U->token;U->port=PORT;goto parse
#define STRDUP(s) (s?Str_dup(s):NULL)
#define STRNDUP(s, n) (s?Str_ndup(s, n):NULL)
	

/* ------------------------------------------------------------ Prototypes */


static int x2b(char *x);
static int parseURL(T U);
static void setParams(T U);
static void freeParams(param_t p);


/* ----------------------------------------------------- Protected methods */


#ifdef ZILD_PACKAGE_PROTECTED
#pragma GCC visibility push(hidden)
#endif

T URL_new(const char *url) {
	T U;
	if (! (url && *url))
		return NULL;
#ifndef ZILD_PACKAGE_PROTECTED
        Exception_init();
#endif
	NEW(U);
	U->data = (uchar_t*)Str_dup(url);
	YYCURSOR = U->data;
	U->port = UNKNOWN_PORT;
	YYLIMIT = U->data + strlen(U->data);
	if (parseURL(U)) {
                if (U->query) 
                        setParams(U);
		return U;
        } 
	URL_free(&U);
	return NULL;
}


T URL_create(const char *url, ...) {
	int n;
	va_list ap;
	uchar_t buf[BUFFER_SIZE];
	if (! (url && *url))
		return NULL;
	va_start(ap, url);
	n = vsnprintf(buf, BUFFER_SIZE, url, ap);
	va_end(ap);
	if (n < 0 || n >= BUFFER_SIZE) 
		return NULL;
	return URL_new(buf);
}


void URL_free(T *U) {
	assert(U && *U);
        if ((*U)->params) freeParams((*U)->params);
        FREE((*U)->paramNames);
	FREE((*U)->toString);
	FREE((*U)->portStr);
	FREE((*U)->query);
	FREE((*U)->data);
	FREE((*U)->host);
	FREE(*U);
}


/* ------------------------------------------------------------ Properties */


const char *URL_getProtocol(T U) {
	assert(U);
	return U->protocol;
}


const char *URL_getUser(T U) {
	assert(U);
	return U->user;
}


const char *URL_getPassword(T U) {
	assert(U);
	return U->password;
}


const char *URL_getHost(T U) {
	assert(U);
	return U->host;
}


int URL_getPort(T U) {
	assert(U);
	return U->port;
}


const char *URL_getPath(T U) {
	assert(U);
	return U->path;
}


const char *URL_getQueryString(T U) {
	assert(U);
	return U->query;
}


const char **URL_getParameterNames(T U) {
        assert(U);
        if (U->params && (U->paramNames == NULL)) {
                param_t p;
                int i = 0, len = 0;
                for (p = U->params; p; p = p->next) len++;
                U->paramNames = ALLOC((len + 1) * sizeof(*U->paramNames));
                for (p = U->params; p; p = p->next)
                        U->paramNames[i++] = p->name;
                U->paramNames[i] = NULL;
        }
	return (const char **)U->paramNames;
}


const char *URL_getParameter(T U, const char *name) {
	assert(U);
        if (U->params && name) {
                param_t p;
                for (p = U->params; p; p = p->next) {
                        if (Str_isByteEqual(p->name, name))
                                return p->value;
                }
        }
        return NULL;
}


const char *URL_toString(T U) {
	assert(U);
	if (U->toString == NULL) {
		U->toString = Str_cat("%s://%s%s%s%s%s%s%s%s%s%s", 
                                      U->protocol,
                                      U->user?U->user:"",
                                      U->password?":":"",
                                      U->password?U->password:"",
                                      U->user?"@":"",
                                      U->host?U->host:"",
                                      U->portStr?":":"",
                                      U->portStr?U->portStr:"",
                                      U->path?U->path:"",
                                      U->query?"?":"",
                                      U->query?U->query:""); 
	}
	return U->toString;
}


char *URL_unescape(char *url) {
	if (url && *url) {
                register int x, y;
                for (x=0, y=0; url[y]; ++x, ++y) {
                        if ((url[x] = url[y]) == '+')
                                url[x] = ' ';
                        else if (url[x] == '%') {
                                url[x] = x2b(&url[y+1]);
                                y += 2;
                        }
                }
                url[x] = '\0';
        }
	return url;
}


char *URL_escape(const char *url) {
        char *escaped = NULL;
        if (url) {
                char *p = escaped = ALLOC(3 * strlen(url) + 1);
                for (; *url; url++) {
                        if (urlunsafe[(unsigned char)(*url)]) {
                                *p++= '%';
                                *p++= b2x[(unsigned char)(*url)][0];
                                *p++= b2x[(unsigned char)(*url)][1];
                        } else {
                                *(p++) = *url;
                        }
                }
                *p = 0;
        }
        return escaped;
}


char *URL_normalize(char *path) {
        char c;
	int i,j;
	if (! path)
		return NULL;
        for (i=j=0; (c=path[i]); ++i) {
                if (c=='/') {
                        while (path[i+1]=='/') ++i;	
                } else if (c=='.' && j && path[j-1]=='/') {
                        if (path[i+1]=='.' && (path[i+2]=='/' || path[i+2]==0)) {
                                if (j>1)
                                        for (j-=2; path[j]!='/' && j>0; --j);
                                i+=2;
                        } else if (path[i+1]=='/' || path[i+1]==0) {
                                ++i;
                                continue;
                        } else
                                c=':';
                }
                if (! (path[j]=path[i])) break; ++j;
	}
	if (! j) { path[0]='/'; j=1; }
	path[j]=0;
	if (path[0]=='/' && path[1]=='/') {
		for (i=j=0;(c=path[i]); ++i) {
			if (c=='/') {
				while (path[i+1]=='/') ++i;	
			}
			if (! (path[j]=path[i])) break; 
			++j;
		}
		path[j]=0;
	}
	return path;
}

#ifdef ZILD_PACKAGE_PROTECTED
#pragma GCC visibility pop
#endif


/* ------------------------------------------------------- Private methods */


static int parseURL(T U) {
	#line 392 "src/net/URL.re"

proto:
	if (YYCURSOR >= YYLIMIT)
		return false;
	YYTOKEN=  YYCURSOR;
	
#line 391 "<stdout>"
{
	YYCTYPE yych;
	static const unsigned char yybm[] = {
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		128, 128, 128, 128, 128, 128, 128, 128, 
		128, 128,   0,   0,   0,   0,   0,   0, 
		  0, 128, 128, 128, 128, 128, 128, 128, 
		128, 128, 128, 128, 128, 128, 128, 128, 
		128, 128, 128, 128, 128, 128, 128, 128, 
		128, 128, 128,   0,   0,   0,   0,   0, 
		  0, 128, 128, 128, 128, 128, 128, 128, 
		128, 128, 128, 128, 128, 128, 128, 128, 
		128, 128, 128, 128, 128, 128, 128, 128, 
		128, 128, 128,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
	};

	if ((YYLIMIT - YYCURSOR) < 13) YYFILL(13);
	yych = *YYCURSOR;
	if (yych <= '9') {
		if (yych <= '\r') {
			if (yych <= 0x08) goto yy8;
			if (yych <= '\n') goto yy2;
			if (yych <= '\f') goto yy8;
		} else {
			if (yych == ' ') goto yy2;
			if (yych <= '/') goto yy8;
			goto yy7;
		}
	} else {
		if (yych <= 'l') {
			if (yych <= '@') goto yy8;
			if (yych <= 'Z') goto yy7;
			if (yych <= '`') goto yy8;
			goto yy7;
		} else {
			if (yych <= 'o') {
				if (yych <= 'm') goto yy4;
				goto yy7;
			} else {
				if (yych <= 'p') goto yy6;
				if (yych <= 'z') goto yy7;
				goto yy8;
			}
		}
	}
yy2:
	++YYCURSOR;
#line 399 "src/net/URL.re"
	{
                        goto proto;
		   }
#line 464 "<stdout>"
yy4:
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= 'Z') {
		if (yych <= '/') goto yy5;
		if (yych <= ':') goto yy12;
		if (yych >= 'A') goto yy12;
	} else {
		if (yych <= 'x') {
			if (yych >= 'a') goto yy12;
		} else {
			if (yych <= 'y') goto yy29;
			if (yych <= 'z') goto yy12;
		}
	}
yy5:
#line 415 "src/net/URL.re"
	{
                      	goto proto;
                   }
#line 484 "<stdout>"
yy6:
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= 'Z') {
		if (yych <= '/') goto yy5;
		if (yych <= ':') goto yy12;
		if (yych <= '@') goto yy5;
		goto yy12;
	} else {
		if (yych <= 'n') {
			if (yych <= '`') goto yy5;
			goto yy12;
		} else {
			if (yych <= 'o') goto yy16;
			if (yych <= 'z') goto yy12;
			goto yy5;
		}
	}
yy7:
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= '@') {
		if (yych <= '/') goto yy5;
		if (yych <= ':') goto yy12;
		goto yy5;
	} else {
		if (yych <= 'Z') goto yy12;
		if (yych <= '`') goto yy5;
		if (yych <= 'z') goto yy12;
		goto yy5;
	}
yy8:
	yych = *++YYCURSOR;
	goto yy5;
yy9:
	yych = *++YYCURSOR;
	if (yych == '/') goto yy13;
yy10:
	YYCURSOR = YYMARKER;
	goto yy5;
yy11:
	++YYCURSOR;
	if ((YYLIMIT - YYCURSOR) < 3) YYFILL(3);
	yych = *YYCURSOR;
yy12:
	if (yybm[0+yych] & 128) {
		goto yy11;
	}
	if (yych == ':') goto yy9;
	goto yy10;
yy13:
	yych = *++YYCURSOR;
	if (yych != '/') goto yy10;
	++YYCURSOR;
#line 411 "src/net/URL.re"
	{
                      	SET_PROTOCOL(UNKNOWN_PORT);
                   }
#line 541 "<stdout>"
yy16:
	yych = *++YYCURSOR;
	if (yych != 's') goto yy12;
	yych = *++YYCURSOR;
	if (yych != 't') goto yy12;
	yych = *++YYCURSOR;
	if (yych != 'g') goto yy12;
	yych = *++YYCURSOR;
	if (yych != 'r') goto yy12;
	yych = *++YYCURSOR;
	if (yych != 'e') goto yy12;
	yych = *++YYCURSOR;
	if (yych != 's') goto yy12;
	yych = *++YYCURSOR;
	if (yych != 'q') goto yy12;
	yych = *++YYCURSOR;
	if (yych != 'l') goto yy12;
	yych = *++YYCURSOR;
	if (yych != ':') goto yy12;
	yych = *++YYCURSOR;
	if (yych != '/') goto yy10;
	yych = *++YYCURSOR;
	if (yych != '/') goto yy10;
	++YYCURSOR;
#line 407 "src/net/URL.re"
	{
                      	SET_PROTOCOL(POSTGRESQL_DEFAULT_PORT);
                   }
#line 570 "<stdout>"
yy29:
	yych = *++YYCURSOR;
	if (yych != 's') goto yy12;
	yych = *++YYCURSOR;
	if (yych != 'q') goto yy12;
	yych = *++YYCURSOR;
	if (yych != 'l') goto yy12;
	yych = *++YYCURSOR;
	if (yych != ':') goto yy12;
	yych = *++YYCURSOR;
	if (yych != '/') goto yy10;
	yych = *++YYCURSOR;
	if (yych != '/') goto yy10;
	++YYCURSOR;
#line 403 "src/net/URL.re"
	{
                      	SET_PROTOCOL(MYSQL_DEFAULT_PORT);
                   }
#line 589 "<stdout>"
}
#line 418 "src/net/URL.re"

parse:
	if (YYCURSOR >= YYLIMIT)
		return true;
	YYTOKEN=  YYCURSOR;
	
#line 598 "<stdout>"
{
	YYCTYPE yych;
	unsigned int yyaccept = 0;
	static const unsigned char yybm[] = {
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		 16, 112, 112,  16, 112, 112, 112, 112, 
		112, 112, 112, 112, 112, 240, 112, 112, 
		248, 248, 248, 248, 248, 248, 248, 248, 
		248, 248, 112,  16, 112, 112, 112,  16, 
		 64, 240, 240, 240, 240, 240, 240, 240, 
		240, 240, 240, 240, 240, 240, 240, 240, 
		240, 240, 240, 240, 240, 240, 240, 240, 
		240, 240, 240, 112, 112, 112, 112, 112, 
		112, 240, 240, 240, 240, 240, 240, 240, 
		240, 240, 240, 240, 240, 240, 240, 240, 
		240, 240, 240, 240, 240, 240, 240, 240, 
		240, 240, 240, 112, 112, 112, 112, 112, 
		112, 112, 112, 112, 112, 112, 112, 112, 
		112, 112, 112, 112, 112, 112, 112, 112, 
		112, 112, 112, 112, 112, 112, 112, 112, 
		112, 112, 112, 112, 112, 112, 112, 112, 
		112, 112, 112, 112, 112, 112, 112, 112, 
		112, 112, 112, 112, 112, 112, 112, 112, 
		112, 112, 112, 112, 112, 112, 112, 112, 
		112, 112, 112, 112, 112, 112, 112, 112, 
		112, 112, 112, 112, 112, 112, 112, 112, 
		112, 112, 112, 112, 112, 112, 112, 112, 
		112, 112, 112, 112, 112, 112, 112, 112, 
		112, 112, 112, 112, 112, 112, 112, 112, 
		112, 112, 112, 112, 112, 112, 112, 112, 
		112, 112, 112, 112, 112, 112, 112, 112, 
		112, 112, 112, 112, 112, 112, 112, 112, 
		112, 112, 112, 112, 112, 112, 112, 112, 
	};
	if ((YYLIMIT - YYCURSOR) < 3) YYFILL(3);
	yych = *YYCURSOR;
	if (yych <= '.') {
		if (yych <= '\r') {
			if (yych <= 0x08) goto yy49;
			if (yych <= '\n') goto yy39;
			if (yych <= '\f') goto yy49;
		} else {
			if (yych <= ' ') {
				if (yych <= 0x1F) goto yy49;
				goto yy41;
			} else {
				if (yych == '-') goto yy44;
				goto yy42;
			}
		}
	} else {
		if (yych <= '?') {
			if (yych <= '/') goto yy46;
			if (yych <= '9') goto yy44;
			if (yych <= ':') goto yy48;
			goto yy42;
		} else {
			if (yych <= 'Z') {
				if (yych <= '@') goto yy49;
				goto yy44;
			} else {
				if (yych <= '`') goto yy42;
				if (yych <= 'z') goto yy44;
				goto yy42;
			}
		}
	}
yy39:
	++YYCURSOR;
yy40:
#line 425 "src/net/URL.re"
	{ 
                        goto parse; 
                   }
#line 676 "<stdout>"
yy41:
	yyaccept = 0;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= 0x1F) goto yy40;
	goto yy56;
yy42:
	yyaccept = 1;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych >= ' ') goto yy56;
yy43:
#line 464 "src/net/URL.re"
	{
                      	return true;
                   }
#line 691 "<stdout>"
yy44:
	yyaccept = 2;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yybm[0+yych] & 128) {
		goto yy67;
	}
	if (yych <= 0x1F) goto yy45;
	if (yych == '.') goto yy66;
	goto yy56;
yy45:
#line 441 "src/net/URL.re"
	{
                        U->host = STRNDUP(YYTOKEN, (YYCURSOR - YYTOKEN));
                        goto parse; 
                   }
#line 707 "<stdout>"
yy46:
	yyaccept = 3;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yybm[0+yych] & 32) {
		goto yy58;
	}
	if (yych <= 0x1F) goto yy47;
	if (yych <= '>') goto yy55;
	if (yych <= '?') goto yy61;
	goto yy60;
yy47:
#line 452 "src/net/URL.re"
	{
                        *YYCURSOR = 0;
                        U->path = YYTOKEN;
                        return true;
                   }
#line 725 "<stdout>"
yy48:
	yyaccept = 1;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yybm[0+yych] & 8) {
		goto yy50;
	}
	if (yych <= 0x1F) goto yy43;
	goto yy56;
yy49:
	yych = *++YYCURSOR;
	goto yy43;
yy50:
	yyaccept = 4;
	YYMARKER = ++YYCURSOR;
	if (YYLIMIT <= YYCURSOR) YYFILL(1);
	yych = *YYCURSOR;
	if (yybm[0+yych] & 8) {
		goto yy50;
	}
	if (yych <= 0x1F) goto yy52;
	if (yych == '@') goto yy53;
	goto yy55;
yy52:
#line 446 "src/net/URL.re"
	{
                        U->portStr = STRNDUP(YYTOKEN+1, (YYCURSOR-YYTOKEN-1));
                        U->port = Str_parseInt(U->portStr);
                        goto parse; 
                   }
#line 755 "<stdout>"
yy53:
	++YYCURSOR;
yy54:
#line 429 "src/net/URL.re"
	{
                        char *p;
                        *(YYCURSOR-1) = 0;
                        U->user = YYTOKEN;
                        p = strchr(U->user, ':');
                        if (p) {
                                *(p++) = 0;
                                U->password = p;
                        }
                        goto parse; 
                   }
#line 771 "<stdout>"
yy55:
	++YYCURSOR;
	if (YYLIMIT <= YYCURSOR) YYFILL(1);
	yych = *YYCURSOR;
yy56:
	if (yybm[0+yych] & 16) {
		goto yy55;
	}
	if (yych >= '@') goto yy53;
yy57:
	YYCURSOR = YYMARKER;
	if (yyaccept <= 2) {
		if (yyaccept <= 1) {
			if (yyaccept <= 0) {
				goto yy40;
			} else {
				goto yy43;
			}
		} else {
			goto yy45;
		}
	} else {
		if (yyaccept <= 4) {
			if (yyaccept <= 3) {
				goto yy47;
			} else {
				goto yy52;
			}
		} else {
			goto yy62;
		}
	}
yy58:
	yyaccept = 3;
	YYMARKER = ++YYCURSOR;
	if ((YYLIMIT - YYCURSOR) < 2) YYFILL(2);
	yych = *YYCURSOR;
	if (yybm[0+yych] & 32) {
		goto yy58;
	}
	if (yych <= 0x1F) goto yy47;
	if (yych <= '>') goto yy55;
	if (yych <= '?') goto yy61;
yy60:
	yych = *++YYCURSOR;
	if (yych <= '#') {
		if (yych <= ' ') goto yy54;
		if (yych <= '"') goto yy64;
		goto yy54;
	} else {
		if (yych == ';') goto yy54;
		goto yy64;
	}
yy61:
	yyaccept = 5;
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych >= ' ') goto yy56;
yy62:
#line 458 "src/net/URL.re"
	{
                        *(YYCURSOR-1) = 0;
                        U->path = YYTOKEN;
                        goto query; 
                   }
#line 836 "<stdout>"
yy63:
	++YYCURSOR;
	if (YYLIMIT <= YYCURSOR) YYFILL(1);
	yych = *YYCURSOR;
yy64:
	if (yybm[0+yych] & 64) {
		goto yy63;
	}
	if (yych <= '>') goto yy47;
	yych = *++YYCURSOR;
	goto yy62;
yy66:
	++YYCURSOR;
	if (YYLIMIT <= YYCURSOR) YYFILL(1);
	yych = *YYCURSOR;
	if (yych <= '9') {
		if (yych <= ',') {
			if (yych <= 0x1F) goto yy57;
			goto yy55;
		} else {
			if (yych <= '-') goto yy69;
			if (yych <= '/') goto yy55;
			goto yy69;
		}
	} else {
		if (yych <= 'Z') {
			if (yych <= '?') goto yy55;
			if (yych <= '@') goto yy53;
			goto yy69;
		} else {
			if (yych <= '`') goto yy55;
			if (yych <= 'z') goto yy69;
			goto yy55;
		}
	}
yy67:
	yyaccept = 2;
	YYMARKER = ++YYCURSOR;
	if (YYLIMIT <= YYCURSOR) YYFILL(1);
	yych = *YYCURSOR;
	if (yybm[0+yych] & 128) {
		goto yy67;
	}
	if (yych <= '.') {
		if (yych <= 0x1F) goto yy45;
		if (yych <= '-') goto yy55;
		goto yy66;
	} else {
		if (yych == '@') goto yy53;
		goto yy55;
	}
yy69:
	yyaccept = 2;
	YYMARKER = ++YYCURSOR;
	if (YYLIMIT <= YYCURSOR) YYFILL(1);
	yych = *YYCURSOR;
	if (yych <= '9') {
		if (yych <= '-') {
			if (yych <= 0x1F) goto yy45;
			if (yych <= ',') goto yy55;
			goto yy69;
		} else {
			if (yych <= '.') goto yy66;
			if (yych <= '/') goto yy55;
			goto yy69;
		}
	} else {
		if (yych <= 'Z') {
			if (yych <= '?') goto yy55;
			if (yych <= '@') goto yy53;
			goto yy69;
		} else {
			if (yych <= '`') goto yy55;
			if (yych <= 'z') goto yy69;
			goto yy55;
		}
	}
}
#line 468 "src/net/URL.re"

query:
	if (YYCURSOR >= YYLIMIT)
		return true;
	YYTOKEN =  YYCURSOR;
	
#line 922 "<stdout>"
{
	YYCTYPE yych;
	static const unsigned char yybm[] = {
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0, 128, 128,   0, 128, 128, 128, 128, 
		128, 128, 128, 128, 128, 128, 128, 128, 
		128, 128, 128, 128, 128, 128, 128, 128, 
		128, 128, 128, 128, 128, 128, 128, 128, 
		128, 128, 128, 128, 128, 128, 128, 128, 
		128, 128, 128, 128, 128, 128, 128, 128, 
		128, 128, 128, 128, 128, 128, 128, 128, 
		128, 128, 128, 128, 128, 128, 128, 128, 
		128, 128, 128, 128, 128, 128, 128, 128, 
		128, 128, 128, 128, 128, 128, 128, 128, 
		128, 128, 128, 128, 128, 128, 128, 128, 
		128, 128, 128, 128, 128, 128, 128, 128, 
		128, 128, 128, 128, 128, 128, 128, 128, 
		128, 128, 128, 128, 128, 128, 128, 128, 
		128, 128, 128, 128, 128, 128, 128, 128, 
		128, 128, 128, 128, 128, 128, 128, 128, 
		128, 128, 128, 128, 128, 128, 128, 128, 
		128, 128, 128, 128, 128, 128, 128, 128, 
		128, 128, 128, 128, 128, 128, 128, 128, 
		128, 128, 128, 128, 128, 128, 128, 128, 
		128, 128, 128, 128, 128, 128, 128, 128, 
		128, 128, 128, 128, 128, 128, 128, 128, 
		128, 128, 128, 128, 128, 128, 128, 128, 
		128, 128, 128, 128, 128, 128, 128, 128, 
		128, 128, 128, 128, 128, 128, 128, 128, 
		128, 128, 128, 128, 128, 128, 128, 128, 
		128, 128, 128, 128, 128, 128, 128, 128, 
		128, 128, 128, 128, 128, 128, 128, 128, 
	};
	if ((YYLIMIT - YYCURSOR) < 2) YYFILL(2);
	yych = *YYCURSOR;
	if (yych <= ' ') goto yy75;
	if (yych == '#') goto yy75;
	goto yy74;
yy73:
#line 475 "src/net/URL.re"
	{
                        *YYCURSOR = 0;
                        U->qptr = YYTOKEN;
                        U->query = STRNDUP(YYTOKEN, (YYCURSOR-YYTOKEN));
                        return true;
                   }
#line 972 "<stdout>"
yy74:
	yych = *++YYCURSOR;
	goto yy78;
yy75:
	++YYCURSOR;
#line 482 "src/net/URL.re"
	{ 
                      return true;     
                   }
#line 982 "<stdout>"
yy77:
	++YYCURSOR;
	if (YYLIMIT <= YYCURSOR) YYFILL(1);
	yych = *YYCURSOR;
yy78:
	if (yybm[0+yych] & 128) {
		goto yy77;
	}
	goto yy73;
}
#line 486 "src/net/URL.re"

        return false;
}


/*
 * Scan the query string for params. 
 * RFC 2396/3.3 URL path parameters are ignored in this version
 */
static void setParams(T U) {
	uchar_t *l, *s, *t;
        param_t param = NULL;
        s = U->qptr;
	l = s + strlen(s);
#undef YYCURSOR
#undef YYLIMIT
#undef YYMARKER
#undef YYFILL
#undef YYTOKEN
#define YYCURSOR        s
#define YYLIMIT         l
#define YYMARKER        
#define YYFILL(n)
#define YYTOKEN         t
start:
        if (YYCURSOR >= YYLIMIT)
                return;
	YYTOKEN = YYCURSOR;
	
#line 1023 "<stdout>"
{
	YYCTYPE yych;
	static const unsigned char yybm[] = {
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0,   0,   0,   0,   0,   0,   0,   0, 
		  0, 192, 192, 192, 192, 192, 128, 192, 
		192, 192, 192, 192, 192, 192, 192, 192, 
		192, 192, 192, 192, 192, 192, 192, 192, 
		192, 192, 192, 192, 192,  64, 192, 192, 
		192, 192, 192, 192, 192, 192, 192, 192, 
		192, 192, 192, 192, 192, 192, 192, 192, 
		192, 192, 192, 192, 192, 192, 192, 192, 
		192, 192, 192, 192, 192, 192, 192, 192, 
		192, 192, 192, 192, 192, 192, 192, 192, 
		192, 192, 192, 192, 192, 192, 192, 192, 
		192, 192, 192, 192, 192, 192, 192, 192, 
		192, 192, 192, 192, 192, 192, 192, 192, 
		192, 192, 192, 192, 192, 192, 192, 192, 
		192, 192, 192, 192, 192, 192, 192, 192, 
		192, 192, 192, 192, 192, 192, 192, 192, 
		192, 192, 192, 192, 192, 192, 192, 192, 
		192, 192, 192, 192, 192, 192, 192, 192, 
		192, 192, 192, 192, 192, 192, 192, 192, 
		192, 192, 192, 192, 192, 192, 192, 192, 
		192, 192, 192, 192, 192, 192, 192, 192, 
		192, 192, 192, 192, 192, 192, 192, 192, 
		192, 192, 192, 192, 192, 192, 192, 192, 
		192, 192, 192, 192, 192, 192, 192, 192, 
		192, 192, 192, 192, 192, 192, 192, 192, 
		192, 192, 192, 192, 192, 192, 192, 192, 
		192, 192, 192, 192, 192, 192, 192, 192, 
		192, 192, 192, 192, 192, 192, 192, 192, 
		192, 192, 192, 192, 192, 192, 192, 192, 
	};
	if ((YYLIMIT - YYCURSOR) < 2) YYFILL(2);
	yych = *YYCURSOR;
	if (yych <= ' ') goto yy85;
	if (yych == '=') goto yy83;
	YYCTXMARKER = YYCURSOR + 1;
	++YYCURSOR;
	yych = *YYCURSOR;
	goto yy93;
yy82:
#line 516 "src/net/URL.re"
	{
                        /* No parameters, but a querystring */
                        return;
                   }
#line 1074 "<stdout>"
yy83:
	++YYCURSOR;
	yych = *YYCURSOR;
	goto yy88;
yy84:
#line 529 "src/net/URL.re"
	{
                        *YYTOKEN++= 0;
                        if (*(YYCURSOR-1)=='&')
                                *(YYCURSOR-1)= 0;
                        if (param==NULL) /* format error */
                                return; 
                         param->value = YYTOKEN;
			 goto start;
                   }
#line 1090 "<stdout>"
yy85:
	++YYCURSOR;
#line 539 "src/net/URL.re"
	{ 
	                 return;
		   }
#line 1097 "<stdout>"
yy87:
	++YYCURSOR;
	if (YYLIMIT <= YYCURSOR) YYFILL(1);
	yych = *YYCURSOR;
yy88:
	if (yybm[0+yych] & 64) {
		goto yy87;
	}
	if (yych <= '%') goto yy84;
	yych = *++YYCURSOR;
	goto yy84;
yy90:
	++YYCURSOR;
	YYCURSOR = YYCTXMARKER;
#line 521 "src/net/URL.re"
	{
                        NEW(param);
                        param->name = YYTOKEN;
                        param->next = U->params;
                        U->params = param;
                        goto start;
                   }
#line 1120 "<stdout>"
yy92:
	YYCTXMARKER = YYCURSOR + 1;
	++YYCURSOR;
	if (YYLIMIT <= YYCURSOR) YYFILL(1);
	yych = *YYCURSOR;
yy93:
	if (yybm[0+yych] & 128) {
		goto yy92;
	}
	if (yych <= '<') goto yy82;
	goto yy90;
}
#line 542 "src/net/URL.re"

}


static int x2b(char *x) {
	register int b;
	b = ((x[0] >= 'A') ? ((x[0] & 0xdf) - 'A')+10 : (x[0] - '0'));
	b *= 16;
	b += (x[1] >= 'A' ? ((x[1] & 0xdf) - 'A')+10 : (x[1] - '0'));
	return b;
}


static void freeParams(param_t p) {
        param_t q;
        for (;p; p = q) {
                q = p->next;
                FREE(p);
        }
}
